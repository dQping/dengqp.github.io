<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>Promise | DEMi&#39;S BLOG</title>
  <!-- Meta data -->
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="generator" content="DEMi'S BLOG" />
  <meta name="author" content="Demi Deng" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />

  <!-- Favicon, (keep icon in root folder) -->
  <link
    rel="Shortcut Icon"
    href="/img/favicon.ico"
    type="image/ico"
  />

  <link
    rel="alternate"
    href="/atom.xml"
    title="DEMi&#39;S BLOG"
    type="application/atom+xml"
  />
  <link
    rel="stylesheet"
    href="/css/all.css"
    media="screen"
    type="text/css"
  />
  <link
    rel="stylesheet"
    href="/css/gitment.css"
    media="screen"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/highlightjs/vs.css"
    type="text/css"
  />
  

  <!--[if IE 8]>
    <link
      rel="stylesheet"
      type="text/css"
      href="/css/ie8.css"
    />
  <![endif]-->

  <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
  <script src="/js/jquery-1.11.1.min.js"></script>
  <script src="/js/gitment.browser.js"></script>
  <script src="/js/busuanzi.js"></script>
  <script>
    window.jQuery ||
      document.write('<script src="js/jquery-1.11.1.min.js"><\/script>');
  </script>

  <!-- Load these in the <head> for quicker IE8+ load times -->
  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
  <![endif]-->

    

  <style>
    .col-md-8.col-md-offset-2.opening-statement img {
      display: none;
    }
  </style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAAs</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/Vue-cli项目构建/" class="animsition-link">Vue-cli项目构建<small>(6)</small></a></li>
				    
				    <li><a href="/categories/antd/" class="animsition-link">antd<small>(1)</small></a></li>
				    
				    <li><a href="/categories/css/" class="animsition-link">css<small>(1)</small></a></li>
				    
				    <li><a href="/categories/git/" class="animsition-link">git<small>(1)</small></a></li>
				    
				    <li><a href="/categories/gulp/" class="animsition-link">gulp<small>(1)</small></a></li>
				    
				    <li><a href="/categories/javascript/" class="animsition-link">javascript<small>(6)</small></a></li>
				    
				    <li><a href="/categories/javascript插件/" class="animsition-link">javascript插件<small>(1)</small></a></li>
				    
				    <li><a href="/categories/npm/" class="animsition-link">npm<small>(1)</small></a></li>
				    
				    <li><a href="/categories/react学习/" class="animsition-link">react学习<small>(6)</small></a></li>
				    
				    <li><a href="/categories/webpack/" class="animsition-link">webpack<small>(1)</small></a></li>
				    
				    <li><a href="/categories/前端知识基础/" class="animsition-link">前端知识基础<small>(17)</small></a></li>
				    
				    <li><a href="/categories/收藏集/" class="animsition-link">收藏集<small>(1)</small></a></li>
				    
				    <li><a href="/categories/日记/" class="animsition-link">日记<small>(2)</small></a></li>
				    
				    <li><a href="/categories/移动端javascript/" class="animsition-link">移动端javascript<small>(1)</small></a></li>
				    
				    <li><a href="/categories/算法/" class="animsition-link">算法<small>(5)</small></a></li>
				    
				    <li><a href="/categories/自检清单/" class="animsition-link">自检清单<small>(2)</small></a></li>
				    
				    <li><a href="/categories/设计模式/" class="animsition-link">设计模式<small>(6)</small></a></li>
				    
				    <li><a href="/categories/调试/" class="animsition-link">调试<small>(1)</small></a></li>
				    
				</ul>
        	</li>
			
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">DEMi'S BLOG</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
  <div class="container">
    <div class="row col-md-offset-2">
      <div class="col-md-8">
        <h1>Promise</h1>
        <span class="post-meta">
  <time datetime="2019-01-25T16:17:31.000Z" itemprop="datePublished">
    2019-01-26
  </time>
    | 
  <a href="/tags/ES6/">ES6</a>, 
  <a href="/tags/Promise/">Promise</a>     | 
  <a href="/categories/javascript/">javascript</a>  
</span>
<div class="toc">
  <ol class="toc-list"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#undefined"><span class="toc-list-text">Promise</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#undefined"><span class="toc-list-text">Promise 的一些特性</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#undefined"><span class="toc-list-text">实现一个 Promise</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#undefined"><span class="toc-list-text">Promise 的链式调用</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#undefined"><span class="toc-list-text">与 jquery 的链式调用区别</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#undefined"><span class="toc-list-text">实现 Promise 链式调用</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#undefined"><span class="toc-list-text">resolvePromise</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#undefined"><span class="toc-list-text">常用的 promise 方法</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#undefined"><span class="toc-list-text">Promise.defer = Promise.deferred 这个语法糖怎么理解呢？</span></a></li></ol></li></ol>
</div>

      </div>
    </div>

    <div class="col-md-8 col-md-offset-2">
      <p>在学习 Promise 前，先理解两组词： <strong>单线程和多线程、同步和异步。</strong>理解了 <strong>单线程和多线程、同步和异步</strong> 的基础上，再来看单线程的 JavaScript 是如何通过 Promise 来实现异步操作的。</p>
<a id="more"></a>
<p><strong><em>单线程和多线程：</em></strong><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B#1" target="_blank" rel="noopener">线程</a>、<a href="https://www.cnblogs.com/hui-run/p/6625913.html" target="_blank" rel="noopener">多线程和单线程</a>、<a href="https://blog.csdn.net/douglax/article/details/1532258" target="_blank" rel="noopener">单线程与多线程的区别</a>。</p>
<p><strong><em>同步和异步：</em></strong> [文章 1]、[文章 2]、[文章 3]。</p>
<h2><span id="promise">Promise</span></h2><p>promise 怎么理解？在知乎上看到一篇比较通俗易懂的小故事，大家可以看看:<br><a href="https://zhuanlan.zhihu.com/p/19622332" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/19622332</a></p>
<h3><span id="promise-的一些特性">Promise 的一些特性</span></h3><p>首先我们要了解 PromiseA+规范<a href="https://promisesaplus.com/" target="_blank" rel="noopener">promisesaplus.com/</a><br>也可以看  阮大神的书《EcmaScript 入门》学习</p>
<ul>
<li>promise 是有三种状态的，等待态 pending / 成功态 resolved / 失败态 rejected</li>
<li>promise 的状态是可以转换的，可以从 pending -&gt; resolved 或 pending -&gt; rejected，但是 resolved 不能转换为 rejected/pending，rejected 不能转换为 resolved/pending，简而言之即状态只会更改一次</li>
<li>Promise 解决了回调地狱的问题</li>
<li>promise 是有兼容性问题的，node 环境下默认支持，还可以下载相应插件来解决兼容性问题</li>
<li>一旦新建 Promise 就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li>
<li>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<p>Promise 对象是一个构造函数，用来生成 Promise 实例，下面代码创造了一个 Promise 实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Promise构造函数的第一个参数为executor</span><br><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// promise的实例都有then方法</span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>executor 默认在 new 的时候会自动执行</li>
<li>then 方法中，有两个参数，分别是成功的回调函数和失败的回调函数</li>
<li>then 方法是异步的，属于微任务,先执行完同步代码，再执行异步代码，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(&apos;1&apos;)</span><br><span class="line">    setTimeout(()=&gt;&#123; // 异步行为</span><br><span class="line">        resolve() // 更改状态为成功</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;success1&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;success2&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&quot;2&quot;)</span><br><span class="line"></span><br><span class="line">此时输出顺序为&apos;1&apos; -&gt; &apos;2&apos; -&gt; &apos;success1&apos; -&gt; &apos;success2&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>同一个 promise 的实例可以 then 多次,成功时会调用所有的成功方法，失败时会调用所有的失败方法</li>
<li>new Promise 中可以支持异步行为</li>
<li>如果发现错误，就会进入失败态,如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123; // 6.resolve、reject函数对应源码实现部分的resolve、reject函数</span><br><span class="line">    resolve(&apos;hello swr&apos;) // 11.执行resolve</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 7.Promise的实例都有then方法</span><br><span class="line">promise.then((data)=&gt;&#123; // 8.成功的回调函数</span><br><span class="line"></span><br><span class="line">&#125;,(err)=&gt;&#123; // 9.失败的回调函数</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3><span id="实现一个-promise">实现一个 Promise</span></h3><p>下面代码部分和源码实现部分要结合来看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ----- 代码部分</span><br><span class="line">// 1.executor默认在new的时候会自动执行</span><br><span class="line">// 成功和失败的视乎可以传递参数</span><br><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123; // 6.resolve、reject函数对应源码实现部分的resolve、reject函数</span><br><span class="line">    resolve(&apos;hello swr&apos;) // 11.执行resolve</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 7.Promise的实例都有then方法</span><br><span class="line">promise.then((data)=&gt;&#123; // 8.成功的回调函数</span><br><span class="line"></span><br><span class="line">&#125;,(err)=&gt;&#123; // 9.失败的回调函数</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// ----- 源码实现部分</span><br><span class="line">// 2.声明一个Promise构造函数</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined // 12.因为value和reason值需要在Promise实例方法then中使用，所以把这两个值，赋给new出来的实例</span><br><span class="line">    function resolve(value)&#123; // 3.声明一个resolve函数</span><br><span class="line">        self.value = value // 13.当调用了resolve并且传参数时，则把这value值赋予self.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reject(reason)&#123; // 4.声明一个reject函数</span><br><span class="line">        self.reason = reason // 13.当调用了reject并且传参数时，则把这reason值赋予self.reason</span><br><span class="line">    &#125;</span><br><span class="line">    executor(resolve,reject) // 5.把resolve、reject函数传到executor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为Promise的实例都有then方法，那么意味着then方法是在Promise的原型对象中的方法</span><br><span class="line">// 10.对应上面成功的回调函数onFulfilled以及失败的回调函数onRejected</span><br><span class="line">Promise.prototype.then = function(onFulfilled,onRejected)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promise // 把Promise暴露出去</span><br></pre></td></tr></table></figure>
<p>此时，我们会发现，如何去判断调用 resolve 还是 reject 呢？ 这个时候我们在内部应该维护一个状态，而我们之前说过了 Promise 有三种状态，分别为 pending、resolved、rejected，那么我们接着看下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ----- 代码部分</span><br><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&apos;hello swr&apos;) // 5.暂时忽略此行</span><br><span class="line">    resolve(&apos;看看同时执行resolve和reject会发生什么？&apos;)  // 5.此行执行resovle</span><br><span class="line">    reject(&apos;看看同时执行resolve和reject会发生什么？&apos;) // 5.此行执行reject</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then((data)=&gt;&#123;</span><br><span class="line">    console.log(&apos;success:&apos; + data) // 5.当调用了resolve函数，则输出success:hello swr</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// ----- 源码实现部分</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined</span><br><span class="line">    self.status = &apos;pending&apos; // 1.在内部维护一个status状态</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        self.value = value</span><br><span class="line">        self.status = &apos;resolved&apos; // 2.当调用了resolve时，更改状态为resolved</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        self.reason = reason</span><br><span class="line">        self.status = &apos;rejected&apos; // 2.当调用了reject时，更改状态为rejected</span><br><span class="line">    &#125;</span><br><span class="line">    executor(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onFulfilled,onRejected)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    // 3.当我们在then中，执行了成功或者失败的回调函数时，首先要判断目前处于什么状态</span><br><span class="line">    if(self.status === &apos;resolved&apos;)&#123;</span><br><span class="line">        onFulfilled(self.value) // 4.当调用了resolve函数后，会执行成功的回调函数，并且把resolve中传递的值，传递给成功的回调函数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(self.status === &apos;rejected&apos;)&#123;</span><br><span class="line">        onRejected(self.reason) // 4.当调用了reject函数后，会执行成功的回调函数，并且把reject中传递的值，传递给失败的回调函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure>
<p>当我们在上面 5 中同时执行 resolve 和 reject，会发现都能够执行，那么就违背了状态只能更改一次的原则了，下面我们来解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ----- 代码部分</span><br><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&apos;看看同时执行resolve和reject会发生什么？&apos;) // 1. 此时执行resolve和reject</span><br><span class="line">    reject(&apos;看看同时执行resolve和reject会发生什么？&apos;) // 3.此时即使调用reject，因为resolve已经调用了一次，从pending更改为resolve，所以在第一次调用后，多次调用也不会生效</span><br><span class="line"></span><br><span class="line">    // 4.以上resolve、reject暂时忽略掉，我们考虑一个情况，当promise抛出错误时，怎么去处理呢？</span><br><span class="line">    throw new Error(&apos;出错啦&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then((data)=&gt;&#123;</span><br><span class="line">    console.log(&apos;success:&apos; + data)</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// ----- 源码实现部分</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined</span><br><span class="line">    self.status = &apos;pending&apos;</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123; // 2.此时新增一个状态判断，当状态为pending的时候才能执行</span><br><span class="line">            self.value = value</span><br><span class="line">            self.status = &apos;resolved&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123; // 2.此时新增一个状态判断，当状态为pending的时候才能执行</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = &apos;rejected&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.当我们在执行executor时，内部抛出错误的时候，可以利用try catch来处理这个问题</span><br><span class="line">    try&#123;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onFulfilled,onRejected)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    if(self.status === &apos;resolved&apos;)&#123;</span><br><span class="line">        onFulfilled(self.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(self.status === &apos;rejected&apos;)&#123;</span><br><span class="line">        onRejected(self.reason)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure>
<p>这样就解决了多次调用，只认第一次的更改状态，并且当抛出错误时，使用 try catch 来处理，那么接下来，想一下，目前我们都是 new 一个 Promise，然后调用 then，这整个流程，仿佛没任何问题，但是，现在问题出现了，如果此时 resolve 或者 reject 是处于 setTimeout(()=&gt;{resolve()},3000)中，即处于异步中，当 new 一个 Promise 时，不会马上执行异步代码，而是直接执行了 promise.then 这个函数，而此时因为 self.status 的状态依然是处于 pending，所以不会执行 resolve 或者 reject，当同步代码执行完毕后，执行异步代码时，更改了状态为 resolved 或者 rejected 时，此时 then 方法已经执行完毕了，不会再次执行 then 的方法，那么此时该如何处理？</p>
<p>还存在一个问题，就是上面所说的，同一个 promise 的实例可以 then 多次,成功时会调用所有的成功方法，失败时会调用所有的失败方法，那这个又该如何处理呢？</p>
<p>可以利用<strong>发布订阅</strong>的思路来解决，如下面代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// ----- 代码部分</span><br><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123; // 1.此时resolve处于异步</span><br><span class="line">        resolve(&apos;hello swr&apos;)</span><br><span class="line">    &#125;,3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then((data)=&gt;&#123; // 多个then</span><br><span class="line">    console.log(&apos;success1:&apos; + data)</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">promise.then((data)=&gt;&#123; // 多个then</span><br><span class="line">    console.log(&apos;success2:&apos; + data)</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// ----- 源码实现部分</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined</span><br><span class="line">    self.status = &apos;pending&apos;</span><br><span class="line">    self.onResolvedCallbacks = [] // 2.可能new Promise中会有异步的操作，此时我们把异步操作时，执行的then函数的成功回调，统一保存在该数组中</span><br><span class="line">    self.onRejectedCallbacks = [] // 2.可能new Promise中会有异步的操作，此时我们把异步操作时，执行的then函数的失败回调，统一保存在该数组中</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.value = value</span><br><span class="line">            self.status = &apos;resolved&apos;</span><br><span class="line">            // 4.当调用resolve时，把该数组中存放的成功回调都执行一遍，如果是异步，则会把成功的回调都存到该数组里了，如果是异步，则没存到。</span><br><span class="line">            self.onResolvedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = &apos;rejected&apos;</span><br><span class="line">            // 4.当调用reject时，把该数组中存放的失败回调都执行一遍，如果是异步，则会把成功的回调都存到该数组里了，如果是异步，则没存到。</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onFulfilled,onRejected)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    if(self.status === &apos;resolved&apos;)&#123;</span><br><span class="line">        onFulfilled(self.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(self.status === &apos;rejected&apos;)&#123;</span><br><span class="line">        onRejected(self.reason)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.当new Promise中有resolve、reject处于异步中，执行then的时候，状态为pending，</span><br><span class="line">    if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">        self.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">            onFulfilled(self.value)</span><br><span class="line">        &#125;) // 3. 把成功的回调函数，存到该数组中，这样写的好处，就是把参数传进去，不需要将来遍历onResolvedCallbacks时，再传参</span><br><span class="line">        self.onRejectedCallbacks.push(()=&gt;&#123;</span><br><span class="line">            onRejected(self.reason)</span><br><span class="line">        &#125;) // 3. 把失败的回调函数，存到该数组中，这样写的好处，就是把参数传进去，不需要将来遍历onRejectedCallbacks时，再传参</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure>
<p>到此为止，简版的 Promise 实现得差不多了。</p>
<h3><span id="promise-的链式调用">Promise 的链式调用</span></h3><p>其实 Promise 的核心在于链式调用，Promise 主要是解决 2 个问题：</p>
<ul>
<li>回调地狱</li>
<li>并发异步 io 操作，同一时间内把这个结果拿到，即比如有两个异步 io 操作，当这 2 个获取完毕后，才执行相应的代码，比如前面所说的 after 函数，发布订阅、Promise.all 等。</li>
</ul>
<p>首先，比如回调地狱怎么解决呢？那么我们来看下面的代码，并且改为 promise。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 回调函数</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">fs.readFile(&apos;./a.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123; // 往fs.readFile方法传递了第三个为函数的参数</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 改写为Promise</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">function read(filePath,encoding)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">            if(err) reject(err)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;./a.txt&apos;,&apos;utf8&apos;).then((data)=&gt;&#123; // 在这里则不再需要传回调函数进去，而是采用then来达到链式调用</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 这样看好像Promise也没什么优势，那么接下来我们对比一下</span><br><span class="line">// 假设有3个文件</span><br><span class="line">// - 1.txt    文本内容为&apos;2.txt&apos;</span><br><span class="line">// - 2.txt    文本内容为&apos;3.txt&apos;</span><br><span class="line">// - 3.txt    文本内容为&apos;hello swr&apos;</span><br><span class="line"></span><br><span class="line">// 用回调函数</span><br><span class="line">fs.readFile(&apos;./1.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">        fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">            console.log(data) // hello swr</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 用Promise</span><br><span class="line">read(&apos;./1.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    // 1.如果一个promise执行完后，返回的还是一个promise，</span><br><span class="line">    //   会把这个promise的执行结果会传递给下一次then中</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    // 2.如果在then中返回的不是一个promise，</span><br><span class="line">    //   而是一个普通值，会将这个普通值作为下次then的成功的结果</span><br><span class="line">    return data.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data) // rws olleh</span><br><span class="line">    // 3.如果当前then中失败了，会走下一个then的失败回调</span><br><span class="line">    throw new Error(&apos;出错&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(null,(err)=&gt;&#123;</span><br><span class="line">    console.log(err) // Error:出错   报错了</span><br><span class="line">    // 4.如果在then中不返回值，虽然没有显式返回，</span><br><span class="line">    //   但是默认是返回undefined，是属于普通值，依然会把这个普通值传到</span><br><span class="line">    //   下一个then的成功回调中</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data) // undefined</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>从上面可以看得出，改写为 Promise 的代码，更好阅读和维护，从用 Promise 方式可以得出结论:</p>
<ul>
<li>1.如果一个 promise 执行完后，返回的还是一个 promise，会把这个 promise 的执行结果会传递给下一次 then 中</li>
<li>2.如果在 then 中返回的不是一个 promise，而是一个普通值，会将这个普通值作为下次 then 的成功的结果</li>
<li>3.如果当前 then 中失败了，会走下一个 then 的失败回调</li>
<li>4.如果在 then 中不返回值，虽然没有显式返回，但是默认是返回 undefined，是属于普通值，依然会把这个普通值传到下一个 then 的成功回调中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 如果在then中抛出错误，会怎样呢？</span><br><span class="line">// 情景一，会被下一个then中的失败回调捕获</span><br><span class="line">read(&apos;./1.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&apos;出错了&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(null,(err)=&gt;&#123;</span><br><span class="line">    console.log(err) // Error:出错了   报错</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 情景二，如果没有被失败的回调捕获，抛出错误最终会变成异常</span><br><span class="line">read(&apos;./1.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&apos;出错了&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 情景三，如果没有被失败的回调捕获，那么最终会被catch捕获到</span><br><span class="line">read(&apos;./1.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&apos;出错了&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">.catch((err)=&gt;&#123;</span><br><span class="line">    console.log(err) // Error:出错了   报错</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 情景四，如果被失败的回调捕获了，那么不会被catch捕获到</span><br><span class="line">read(&apos;./1.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&apos;出错了&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(null,(err)=&gt;&#123;</span><br><span class="line">    console.log(err) // Error:出错了   报错</span><br><span class="line">&#125;)</span><br><span class="line">.catch((err)=&gt;&#123;</span><br><span class="line">    console.log(err)  // 不会执行到这里</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>5.catch 是错误没有处理的情况下才会执行</li>
<li>6.then 中可以不写东西</li>
</ul>
<h3><span id="与-jquery-的链式调用区别">与 jquery 的链式调用区别</span></h3><p>jquery 的链式调用，是通过其内部执行完后 return this，返回自身这个对象，达到链式调用的目的，那为什么 Promise 不采用这种方式呢？<br>可以看以下代码，感受一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve() // 执行resolve，使状态从pending变为resolved</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let promise2 = promise.then(()=&gt;&#123;</span><br><span class="line">    throw new Error() // 抛出错误</span><br><span class="line">    return this // 返回自身</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 那么我在promise2中，调then，那么它会执行失败的回调吗？答案是不会的。</span><br><span class="line">// 因为我们不可能让状态既成功又失败的</span><br><span class="line">// promise成功了，如果返回this，那不能走向失败</span><br><span class="line">promise2.then(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;来到这里了&apos;)</span><br><span class="line">&#125;,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;会来到这里吗？&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 此时then中返回自身后，promise2其实就是promise，而我们想达到</span><br><span class="line">// 的是把当前的then返回后，传到下一个then中，但是我们这样返回this，</span><br><span class="line">// 其实会变得很矛盾，因为状态已经从pending变为resolved，不可能又从resolved变成rejected的</span><br><span class="line">// 所以得出结论，返回的必须是一个新的promise，因为promise成功后不能再走失败</span><br><span class="line">// 只能创建一个新的promise再执行业务逻辑，返回同一个promise的话，就不能既成功又失败</span><br></pre></td></tr></table></figure>
<h3><span id="实现-promise-链式调用">实现 Promise 链式调用</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ----- 代码部分</span><br><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 2.返回的值为promise2 为什么这样规定呢？这是promiseA+规范规定的，我们要遵循</span><br><span class="line">let promise2 = promise.then((data)=&gt;&#123;</span><br><span class="line">    return x // 1.then中的返回值x可能是普通值也可能是promise，并且传给下一个then</span><br><span class="line">&#125;).then((data)=&gt;&#123;</span><br><span class="line">    console.log(data) // x的值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">// ----- 源码实现部分</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined</span><br><span class="line">    self.status = &apos;pending&apos;</span><br><span class="line">    self.onResolvedCallbacks = []</span><br><span class="line">    self.onRejectedCallbacks = []</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.value = value</span><br><span class="line">            self.status = &apos;resolved&apos;</span><br><span class="line">            self.onResolvedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = &apos;rejected&apos;</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onFulfilled,onRejected)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    let promise2 // 3.上面讲promise链式调用时，已经说了返回的是一个新的promise对象，那么我们声明一个新的promise</span><br><span class="line"></span><br><span class="line">    // 4.那么我们new一个新的promise，并且把以下代码放到promise中</span><br><span class="line">    let promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        if(self.status === &apos;resolved&apos;)&#123;</span><br><span class="line">            // 7.当执行成功回调的时候，可能会出现异常，那么就把这个异常作为promise2的错误的结果</span><br><span class="line">            try&#123;</span><br><span class="line">                let x = onFulfilled(self.value) // 6.这里的x，就是上面then中执行完返回的结果，我们在这里声明一个x用来接收</span><br><span class="line">                // 8.根据promiseA+规范，我们应该提供一个函数来处理promise2</span><br><span class="line">                //   我个人的理解是，then中不管是成功回调还是失败回调，其返回</span><br><span class="line">                //   值，有可能是promise，也有可能是普通值，也有可能是抛出错误</span><br><span class="line">                //   那么我们就需要一个函数来处理这几种不同的情况</span><br><span class="line">                //   这个函数我们声明为resolvePromise吧</span><br><span class="line">                resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                // 9. 这里的promise2就是当前的promise2，x则是执行then中成功回调后返回的结果，如果是成功则调promise2的resolve，失败则调reject</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                reject(e) // 注意：这里的reject是这个promise2的reject</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(self.status === &apos;rejected&apos;)&#123;</span><br><span class="line">            // 同6-7步</span><br><span class="line">            try&#123;</span><br><span class="line">                let x = onRejected(self.reason)</span><br><span class="line">                // 同8-9</span><br><span class="line">                resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">                // 同6-7步</span><br><span class="line">                try&#123;</span><br><span class="line">                    let x =  onFulfilled(self.value)</span><br><span class="line">                    // 同8-9</span><br><span class="line">                    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            self.onRejectedCallbacks.push(()=&gt;&#123;</span><br><span class="line">                // 同6-7步</span><br><span class="line">                try&#123;</span><br><span class="line">                    let x = onRejected(self.reason)</span><br><span class="line">                    // 同8-9</span><br><span class="line">                    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise2 // 5.在jquery中是return this，但是在promise中，则是返回一个新的promise对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure>
<h3><span id="resolvepromise">resolvePromise</span></h3><p>接下来写一下 resolvePromise 这个函数，整个 Promise 最核心的部分就是在这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// ----- 代码部分</span><br><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let promise2 = promise.then((data)=&gt;&#123;</span><br><span class="line">    return x</span><br><span class="line">&#125;).then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 2.我们在resolvePromise函数中，在原生情况下，如果传参的时候，promise2和x是同一个对象会发生什么呢？</span><br><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let promise2 = promise.then(()=&gt;&#123;</span><br><span class="line">    return promise2</span><br><span class="line">    // 2.1报错 UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br><span class="line">    // 报错的意思是，陷入了死循环，那怎么理解呢？</span><br><span class="line">    // promise2的成功或失败是要取决于promise中then的返回结果，而返回的却是promise2自己</span><br><span class="line">    // 这样就陷入死循环了，promise2是依赖于promise的then返回的结果，</span><br><span class="line">    // 而then返回的结果是promise2，而then中的promise2，既不是成功也不是失败，不能自己等于自己</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 7.当取一个对象上的属性，可能存在报异常的情况，怎么理解呢？</span><br><span class="line">// 因为这个方法有可能不是自己写的，可能别人搞恶作剧乱写的，看以下代码。</span><br><span class="line">let obj = &#123;&#125;</span><br><span class="line">// 给obj对象定义一个then方法，当我们去obj对象中调用then方法时</span><br><span class="line">// 就会执行里面的get，而get则是抛出异常</span><br><span class="line">Object.defineProperty(obj,&apos;then&apos;,&#123;</span><br><span class="line">    get()&#123;</span><br><span class="line">        throw new Error()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 10.为什么要用call呢？解决了什么问题？看一下以下代码</span><br><span class="line">首先我们执行</span><br><span class="line">promise.then(()=&gt;&#123;</span><br><span class="line">    console.log(this) // 此时this是指向该promise的，对象的方法中this是指向这个对象的</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">但是我们在下面通过let then = promise.then，来判断是否promise，是否会异常</span><br><span class="line">当我们执行then时，里面的this还是会指向这个promise吗？答案是不一定的，</span><br><span class="line">因为此时then，如果在全局下执行，指向的可能就是window了，所以为了让this的</span><br><span class="line">指向正确，我们需要通过</span><br><span class="line">then.call(promise)，来把then的this指向promise</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">// ----- 源码实现部分</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined</span><br><span class="line">    self.status = &apos;pending&apos;</span><br><span class="line">    self.onResolvedCallbacks = []</span><br><span class="line">    self.onRejectedCallbacks = []</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.value = value</span><br><span class="line">            self.status = &apos;resolved&apos;</span><br><span class="line">            self.onResolvedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = &apos;rejected&apos;</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1.声明一个resolvePromise函数</span><br><span class="line">// 这个函数非常核心，所有的promise都遵循这个规范，所有的promise可以通用，</span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;*&#125; promise2 then的返回值，返回新的promise</span><br><span class="line"> * @param &#123;*&#125; x then中成功函数或者失败函数的返回值</span><br><span class="line"> * @param &#123;*&#125; resolve promise2的resolve</span><br><span class="line"> * @param &#123;*&#125; reject promise2的reject</span><br><span class="line"> */</span><br><span class="line">function resolvePromise(promise2,x,resolve,reject)&#123;</span><br><span class="line">    // 3.从2中我们可以得出，自己不能等于自己</span><br><span class="line">    // 当promise2和x是同一个对象的时候，则走reject</span><br><span class="line">    if(promise2 === x)&#123;</span><br><span class="line">        return reject(new TypeError(&apos;Chaining cycle detected for promise&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.因为then中的返回值可以为promise，当x为对象或者函数，才有可能返回的是promise</span><br><span class="line">    let called</span><br><span class="line">    if(x !== null &amp;&amp; (typeof x === &apos;object&apos; || typeof x === &apos;function&apos;))&#123;</span><br><span class="line">        // 8.从第7步，可以看出为什么会存在抛出异常的可能，所以使用try catch处理</span><br><span class="line">        try&#123;</span><br><span class="line">            // 6.因为当x为promise的话，是存在then方法的</span><br><span class="line">            // 但是我们取一个对象上的属性，也有可能出现异常，我们可以看一下第7步</span><br><span class="line">            let then = x.then</span><br><span class="line"></span><br><span class="line">            // 9.我们为什么在这里用call呢？解决了什么问题呢？可以看上面的第10步</span><br><span class="line">            // x可能还是个promise，那么就让这个promise执行</span><br><span class="line">            // 但是还是存在一个恶作剧的情况，就是&#123;then:&#123;&#125;&#125;</span><br><span class="line">            // 此时需要新增一个判断then是否函数</span><br><span class="line">            if(typeof === &apos;function&apos;)&#123;</span><br><span class="line">                then.call(x,(y)=&gt;&#123; // y是返回promise后的成功结果</span><br><span class="line">                    // 一开始我们在这里写的是resolve(y)，但是考虑到一点</span><br><span class="line">                    // 这个y，有可能还是一个promise，</span><br><span class="line">                    // 也就是说resolve(new Promise(...))</span><br><span class="line">                    // 所以涉及到递归，我们把resolve(y)改成以下</span><br><span class="line"></span><br><span class="line">                    // 12.限制既调resolve，也调reject</span><br><span class="line">                    if(called) return</span><br><span class="line">                    called = true</span><br><span class="line"></span><br><span class="line">                    resolvePromise(promise2,y,resolve,reject)</span><br><span class="line">                    // 这样的话，代码会一直递归，取到最后一层promise</span><br><span class="line"></span><br><span class="line">                    // 11.这里有一种情况，就是不能既调成功也调失败，只能挑一次，</span><br><span class="line">                    // 但是我们前面不是处理过这个情况了吗？</span><br><span class="line">                    // 理论上是这样的，但是我们前面也说了，resolvePromise这个函数</span><br><span class="line">                    // 是所有promise通用的，也可以是别人写的promise，如果别人</span><br><span class="line">                    // 的promise可能既会调resolve也会调reject，那么就会出问题了，所以我们接下来要</span><br><span class="line">                    // 做一下限制，这个我们写在第12步</span><br><span class="line"></span><br><span class="line">                &#125;,(err)=&gt;&#123; // err是返回promise后的失败结果</span><br><span class="line">                    if(called) return</span><br><span class="line">                    called = true</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resolve(x) // 如果then不是函数的话，那么则是普通对象，直接走resolve成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(e)&#123; // 当出现异常则直接走reject失败</span><br><span class="line">            if(called) return</span><br><span class="line">            called = true</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123; // 5.x为一个常量，则是走resolve成功</span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onFulfilled,onRejected)&#123;</span><br><span class="line">    // onFulfilled、onRejected是可选参数</span><br><span class="line">    onFulfilled = typeof onFulfilled === &apos;function&apos;?onFulfilled:val=&gt;val;</span><br><span class="line">    onRejected = typeof onRejected === &apos;function&apos;?onRejected: err=&gt;&#123;throw err&#125;</span><br><span class="line">    let self = this</span><br><span class="line">    let promise2</span><br><span class="line">    let promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        if(self.status === &apos;resolved&apos;)&#123;</span><br><span class="line">            // 13.根据promiseA+规范，onFulfilled或onRejected必须</span><br><span class="line">            // 被调用不是当前的上下文，then方法是异步的</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    let x = onFulfilled(self.value)</span><br><span class="line">                    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,0)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(self.status === &apos;rejected&apos;)&#123;</span><br><span class="line">            // 同13</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    let x = onRejected(self.reason)</span><br><span class="line">                    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,0)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">                // 同13</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        let x =  onFulfilled(self.value)</span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                    &#125;catch(e)&#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,0)</span><br><span class="line">            &#125;)</span><br><span class="line">            self.onRejectedCallbacks.push(()=&gt;&#123;</span><br><span class="line">                // 同13</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        let x = onRejected(self.reason)</span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                    &#125;catch(e)&#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,0)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 14.到目前为止，根据promiseA+规范的代码写得差不多了，可以通过测试代码来测试我们是否写得正确，下面我们写一段测试代码</span><br><span class="line"></span><br><span class="line">Promise.defer = Promise.deferred = function()&#123;</span><br><span class="line">    let dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        dfd.resolve = resolve</span><br><span class="line">        dfd.reject = reject</span><br><span class="line">    &#125;)</span><br><span class="line">    return dfd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 14.接下来我们要安装一个插件，npm install promises-aplus-test -g</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">// 完整代码 也顺便理顺一下</span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line">    let self = this;</span><br><span class="line">    self.value = undefined;  // 成功的值</span><br><span class="line">    self.reason = undefined;  // 失败的值</span><br><span class="line">    self.status = &apos;pending&apos;; // 目前promise的状态pending</span><br><span class="line">    self.onResolvedCallbacks = []; // 可能new Promise的时候会存在异步操作，把成功和失败的回调保存起来</span><br><span class="line">    self.onRejectedCallbacks = [];</span><br><span class="line">    function resolve(value) &#123; // 把状态更改为成功</span><br><span class="line">        if (self.status === &apos;pending&apos;) &#123; // 只有在pending的状态才能转为成功态</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = &apos;resolved&apos;;</span><br><span class="line">            self.onResolvedCallbacks.forEach(fn =&gt; fn()); // 把new Promise时异步操作，存在的成功回调保存起来</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason) &#123;  // 把状态更改为失败</span><br><span class="line">        if (self.status === &apos;pending&apos;) &#123; // 只有在pending的状态才能转为失败态</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = &apos;rejected&apos;;</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn =&gt; fn()); // 把new Promise时异步操作，存在的失败回调保存起来</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 在new Promise的时候，立即执行的函数，称为执行器</span><br><span class="line">        executor(resolve, reject);</span><br><span class="line">    &#125; catch (e) &#123; // 如果执行executor抛出错误，则会走失败reject</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这个函数为核心，所有的promise都遵循这个规范</span><br><span class="line">// 主要是处理then中返回的值x和promise2的关系</span><br><span class="line">function resolvePromise(promise2,x,resolve,reject)&#123;</span><br><span class="line">    // 当promise2和then返回的值x为同一个对象时，变成了自己等自己，会陷入死循环</span><br><span class="line">    if(promise2 === x)&#123;</span><br><span class="line">        return reject(new TypeError(&apos;Chaining cycle&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    let called;</span><br><span class="line">    // x可能是一个promise也可能是一个普通值</span><br><span class="line">    if(x!==null &amp;&amp; (typeof x=== &apos;object&apos; || typeof x === &apos;function&apos;))&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            let then = x.then;</span><br><span class="line">            if(typeof then === &apos;function&apos;)&#123;</span><br><span class="line">                then.call(x,y=&gt;&#123;</span><br><span class="line">                    if(called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    resolvePromise(promise2,y,resolve,reject);</span><br><span class="line">                &#125;,err=&gt;&#123;</span><br><span class="line">                    if(called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            if(called) return;</span><br><span class="line">            called = true;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// then调用的时候，都是属于异步，是一个微任务</span><br><span class="line">// 微任务会比宏任务先执行</span><br><span class="line">// onFulfilled为成功的回调，onRejected为失败的回调</span><br><span class="line">Promise.prototype.then = function (onFulfilled, onRejected) &#123;</span><br><span class="line">    onFulfilled = typeof onFulfilled === &apos;function&apos;?onFulfilled:val=&gt;val;</span><br><span class="line">    onRejected = typeof onRejected === &apos;function&apos;?onRejected: err=&gt;&#123;throw err&#125;</span><br><span class="line">    let self = this;</span><br><span class="line">    let promise2;</span><br><span class="line">    // 上面讲了，promise和jquery的区别，promise不能单纯返回自身，</span><br><span class="line">    // 而是每次都是返回一个新的promise，才可以实现链式调用，</span><br><span class="line">    // 因为同一个promise的pending resolve reject只能更改一次</span><br><span class="line">    promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        if (self.status === &apos;resolved&apos;) &#123;</span><br><span class="line">            // 为什么要加setTimeout？</span><br><span class="line">            // 首先是promiseA+规范要求的</span><br><span class="line">            // 其次是大家写的代码，有的是同步，有的是异步</span><br><span class="line">            // 所以为了更加统一，就使用为setTimeout变为异步了，保持一致性</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                try &#123; // 上面executor虽然使用try catch捕捉错误</span><br><span class="line">                      // 但是在异步中，不一定能够捕捉，所以在这里</span><br><span class="line">                      // 用try catch捕捉</span><br><span class="line">                    let x = onFulfilled(self.value);</span><br><span class="line">                    // 在then中，返回值可能是一个promise，所以</span><br><span class="line">                    // 需要resolvePromise对返回值进行判断</span><br><span class="line">                    resolvePromise(promise2,x,resolve,reject);</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,0)</span><br><span class="line">        &#125;</span><br><span class="line">        if (self.status === &apos;rejected&apos;) &#123;</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x = onRejected(self.reason);</span><br><span class="line">                    resolvePromise(promise2,x,resolve,reject);</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,0)</span><br><span class="line">        &#125;</span><br><span class="line">        if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line">            self.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onFulfilled(self.value);</span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject);</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,0)</span><br><span class="line">            &#125;);</span><br><span class="line">            self.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onRejected(self.reason);</span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject);</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,0)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return promise2</span><br><span class="line">&#125;</span><br><span class="line">Promise.defer = Promise.deferred = function()&#123;</span><br><span class="line">    let dfd = &#123;&#125;;</span><br><span class="line">    dfd.promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;)</span><br><span class="line">    return dfd;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Promise;</span><br></pre></td></tr></table></figure>
<h3><span id="常用的-promise-方法">常用的 promise 方法</span></h3><ul>
<li>Promise.reject</li>
<li>Promise.resolve</li>
<li>catch</li>
<li>Promise.all</li>
<li>Promise.race</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject = function(reason)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.resolve = function(value)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.catch = function(onRejected)&#123;</span><br><span class="line">    return this.then(null,onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.all = function(promises)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let arr = [];</span><br><span class="line">        let i = 0;</span><br><span class="line">        function processData(index,data)&#123;</span><br><span class="line">            arr[index] = data;</span><br><span class="line">            if(++i == promises.length)&#123;</span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(let i = 0;i&lt;promises.length;i++)&#123;</span><br><span class="line">            promises[i].then(data=&gt;&#123;</span><br><span class="line">                processData(i,data);</span><br><span class="line">            &#125;,reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.race = function(promises)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        for(let i = 0;i&lt;promises.length;i++)&#123;</span><br><span class="line">            promises[i].then(resolve,reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Promise.all，这个方法非常重要，同时执行多个异步，并且返回一个新的 promise，成功的值是一个数组，该数组成员的顺序是传参给 Promise.all 的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 原生Promise.all的使用</span><br><span class="line">// 假设1.txt内容为hello 2.txt内容为swr</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">function read(filePath,encoding)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">            if(err) reject(err)</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.all([read(&apos;./1.txt&apos;,&apos;utf8&apos;),read(&apos;./2.txt&apos;,&apos;utf8&apos;)]).then((data)=&gt;&#123;</span><br><span class="line">    console.log(data) // 全部读取成功后返回 [&apos;hello&apos;,&apos;swr&apos;]</span><br><span class="line">                      // 需要注意的是，当其中某个失败的话，则会走失败的回调函数</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 内部实现</span><br><span class="line">Promise.all = function(promises)&#123; // promises 是一个数组</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let arr = []</span><br><span class="line">        let i = 0</span><br><span class="line">        function processData(index,data)&#123;</span><br><span class="line">            arr[index] = data</span><br><span class="line">            // 5.我们能用arr.length === promises.length来判断请求是否全部完成吗？</span><br><span class="line">            // 答案是不行的，假设arr[2] = &apos;hello swr&apos;</span><br><span class="line">            // 那么打印这个arr，将是[empty × 2, &quot;hello swr&quot;]，</span><br><span class="line">            // 此时数组长度也是为3，而数组arr[0] arr[1]则为空</span><br><span class="line">            // 那么换成以下的办法</span><br><span class="line">            if(++i === promises.length)&#123; // 6.利用i自增来判断是否都成功执行</span><br><span class="line">                resolve(arr) // 此时arr 为[&apos;hello&apos;,&apos;swr&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(let i = 0;i &lt; promises.length;i++)&#123; // 1.在此处遍历执行</span><br><span class="line">            promises[i].then((data)=&gt;&#123; // 2.data是成功后返回的结果</span><br><span class="line">                processData(i,data) // 4.因为Promise.all最终返回的是一个数组成员按照顺序排序的数组</span><br><span class="line">                                    // 而且异步执行，返回并不一定按照顺序</span><br><span class="line">                                    // 所以需要传当前的i</span><br><span class="line">            &#125;,reject) // 3.如果其中有一个失败的话，则调用reject</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Promise.race 该方法是同时执行多个异步，然后哪个快，就用哪个的结果，race 的意思是赛跑</p>
<h3><span id="promisedefer-promisedeferred-这个语法糖怎么理解呢">Promise.defer = Promise.deferred 这个语法糖怎么理解呢？</span></h3><p>这个语法糖可以简化一些操作，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">// 写法一：</span><br><span class="line">function read(filePath,encoding)&#123;</span><br><span class="line">    // 这里的new Promise依然是传递了一个executor回调函数</span><br><span class="line">    // 我们该怎样减少回调函数嵌套呢？</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">            if(err) reject(err)</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二：</span><br><span class="line">// 这样的写法减少了一层回调函数的嵌套</span><br><span class="line">function read(filePath,encoding)&#123;</span><br><span class="line">    let dfd = Promise.defer()</span><br><span class="line">    fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">        if(err) dfd.reject(err)</span><br><span class="line">        dfd.resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    return dfd.promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;./1.txt&apos;,&apos;utf8&apos;).then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>主要学习自：<a href="https://juejin.im/post/5b6e5cbf51882519ad61b67e" target="_blank" rel="noopener">文章</a></p>

      <div class="clearfix"></div>
      <hr class="nogutter" />
    </div>
    <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2019/01/26/设计模式-4：原型模式/" style="float: left;">
        ← 设计模式-4：原型模式
    </a>
    
    
    <a class="pull-right" href="/2019/01/25/设计模式-3：观察者模式/">
        设计模式-3：观察者模式/发布订阅模式 →
    </a>
    
</nav>

    <div class="col-md-8 col-md-offset-2 col-sm-24">
      <div id="comments"></div>

<script>
  var gitment = new Gitment({
    id: "Sat Jan 26 2019 00:17:31 GMT+0800",
    owner: "dQping",
    repo: "dqping.github.io",
    oauth: {
      client_id: "2de462c28c32f89059f",
      client_secret: "9d664eef153368ff85f4a56d36783173e02dd462"
    }
  });
  gitment.render("comments");
</script>

    </div>
  </div>
</section>


      <!-- ============================ Footer =========================== -->

<footer>
  <div class="container">
    <div class="copy">
      <p>
        &copy; 2014<script>
          new Date().getFullYear()</script>, Content By Demi Deng. All Rights Reserved.
      </p>
      <p>
        Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a>
      </p>
    </div>
    <div class="social">
      <ul>
        
        <li>
          <a href="https://github.com/" title="Github" target="_blank"
            ><i class="icon-github"></i></a
          >&nbsp;
        </li>
         
        <li>
          <a href="https://twitter.com/" title="Twitter" target="_blank"
            ><i class="icon-twitter"></i></a
          >&nbsp;
        </li>
         
        <li>
          <a href="https://www.facebook.com/" title="Facebook" target="_blank"
            ><i class="icon-facebook"></i></a
          >&nbsp;
        </li>
         
        <li>
          <a href="https://google.com/" title="Google-Plus" target="_blank"
            ><i class="icon-google-plus"></i></a
          >&nbsp;
        </li>
         
        <li>
          <a href="http://weibo.com/" title="Sina-Weibo" target="_blank"
            ><i class="icon-sina-weibo"></i></a
          >&nbsp;
        </li>
        
      </ul>
      <p>
        <!-- <span id="busuanzi_container_site_uv">
          本站访客数<span id="busuanzi_value_site_uv"></span>人次
        </span> -->
        <span id="busuanzi_container_site_pv"
          >总访问量<span id="busuanzi_value_site_pv"></span>次</span
        >
      </p>
    </div>
    <div class="clearfix"></div>
  </div>
</footer>

<!-- ============================ END Footer =========================== -->

      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
